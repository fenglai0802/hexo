<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Monda:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="黑月的BLooooog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="黑月的BLooooog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="黑月的BLooooog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="黑月的BLooooog">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> 黑月的BLooooog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">黑月的BLooooog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-moon-o"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-bookmark-o"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/06/文件上传组件小结/" itemprop="url">
                  文件上传组件小结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-06T15:05:50+08:00" content="2016-11-06">
              2016-11-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="文件-图片上传组件小结"><a href="#文件-图片上传组件小结" class="headerlink" title="文件/图片上传组件小结"></a>文件/图片上传组件小结</h1><p>分为两部分来总结，第一部分为<em>自定义样式</em>，第二部分为<em>js实现</em>。</p>
<h3 id="一-自定义样式"><a href="#一-自定义样式" class="headerlink" title="一. 自定义样式"></a>一. 自定义样式</h3><p>通常来说，<code>input[type=file]</code>的默认样式都不能满足视觉的需求，所以需要套壳包装。常用的方式就是隐藏默认上传控件，并在其父级添加一个元素（比如label标签）来自定义样式，这样可以做到保留功能同时自定义样式。具体css代码如下：</p>
<pre><code>//HTML5
&lt;img src=&apos;&apos; ref=preview&gt;
&lt;label class=&quot;u-btn btn-upload&quot;&gt;
    &lt;input type=&quot;file&quot; ref=files  on-change={this.fileChange()}&gt;上传图片
&lt;/label&gt;

//CSS
.u-btn {   //基础按钮样式
    font: inherit;
    position:relative;
    line-height: 34px;
    display: inline-block;
    box-sizing: border-box;
    height: 34px;
    margin: 0;
    padding: 0 12px;
    cursor: pointer;
    text-decoration: none;
    color: #444;
    border: 1px solid #ddd;
    -moz-border-radius: 3px;
    border-radius: 3px;
    background: #f4f4f4;
    -webkit-appearance: none;
}
.u-btn:focus, .u-btn:hover {
    text-decoration: none;border: 1px solid #adadad;background: #e5e5e5;
}
.btn-upload {  
    overflow: hidden;
    input{
        opacity: 0;
        filter:alpha(opacity=0);
        font-size: 100px;
        position: absolute;
        top: 0;right: 0
    }
}
</code></pre><h3 id="二-js实现"><a href="#二-js实现" class="headerlink" title="二. js实现"></a>二. js实现</h3><p>需求：上传单张图片，并能预览。</p>
<p>框架：<a href="https://github.com/regularjs/regular" target="_blank" rel="external">regular</a></p>
<pre><code>// 这里使用regular框架，不详细说明
// 在`input[type=file]`上绑定了`onchange`监听事件,回调为`fileChange`方法
fileChange: function(ev) {
    var input = this.$refs.files;  // regular获取节点的方式
    var preview = this.$refs.preview;  // 获取预览dom
    var file = input.files[0]; // 获取上传的文件
    if (!/\/(?:jpeg|jpg|png)/i.test(file.type)) { //检查上传文件的类型，此处需要图片类型的文件，并且规定了后缀条件。
        //提示错误信息
        return;
    }
    var reader = new FileReader();
    var self = this;
    reader.onload = function(e) {

        var result = self.img = this.result; // this指向reader,这个result即上传文件数据，将这个result用ajax传输即可。

        // 组件操作，可忽略
        self.data.show = true;
        self.data.str = &apos;重新选择&apos;
        self.$emit(&apos;upload&apos;);

        preview.src = result; // 预览dom设置src

        // console.log(preview.naturalWidth)
        // console.log(preview.naturalHeight)
        // 组件操作，可忽略
        self.imgNatrualSize = {
            width: preview.naturalWidth,
            height: preview.naturalHeight
        }

        // 获取文件名
        var imgName = input.value;
        var index = imgName.lastIndexOf(&apos;\\&apos;);
        self.imgName = index !== -1 ? imgName.slice(index+1) : imgName;

        input.value = &apos;&apos;; // 清空图片上传框的值

   };

   reader.readAsDataURL(file); // 将文件转成base64的格式.
},
</code></pre><h5 id="附录-FileReader-API简介"><a href="#附录-FileReader-API简介" class="headerlink" title="附录 FileReader API简介"></a>附录 FileReader API简介</h5><h6 id="1-FileReader对象的方法"><a href="#1-FileReader对象的方法" class="headerlink" title="1. FileReader对象的方法"></a>1. FileReader对象的方法</h6><p>FileReader 的实例拥有 4 个方法，其中 3 个用以读取文件，另一个用来中断读取。下面的表格列出了这些方法以及他们的参数和功能，需要注意的是 ，无论读取成功或失败，方法并不会返回读取结果，这一结果存储在 result属性中。</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">abort</td>
<td style="text-align:left">none</td>
<td style="text-align:left">中断读取</td>
</tr>
<tr>
<td style="text-align:left">readAsBinaryString</td>
<td style="text-align:left">file</td>
<td style="text-align:left">将文件读取为二进制码</td>
</tr>
<tr>
<td style="text-align:left">readAsDataURL</td>
<td style="text-align:left">file</td>
<td style="text-align:left">将文件读取为 DataURL</td>
</tr>
<tr>
<td style="text-align:left">readAsText</td>
<td style="text-align:left">file</td>
<td style="text-align:left">将文件读取为文本</td>
</tr>
</tbody>
</table>
<p><em>readAsText</em>：该方法有两个参数，其中第二个参数是文本的编码方式，默认值为 UTF-8。这个方法非常容易理解，将文件以文本方式读取，读取的结果即是这个文本文件中的内容。</p>
<p><em>readAsBinaryString</em>：该方法将文件读取为二进制字符串，通常我们将它传送到后端，后端可以通过这段字符串存储文件。</p>
<p><em>readAsDataURL</em>：这是例子程序中用到的方法，该方法将文件读取为一段以 data: 开头的字符串，这段字符串的实质就是 Data URL，Data URL是一种将小文件直接嵌入文档的方案。这里的小文件通常是指图像与 html 等格式的文件。</p>
<h6 id="2-FileReader对象的事件"><a href="#2-FileReader对象的事件" class="headerlink" title="2. FileReader对象的事件"></a>2. FileReader对象的事件</h6><p>FileReader 包含了一套完整的事件模型，用于捕获读取文件时的状态，下面这个表格归纳了这些事件。</p>
<table>
<thead>
<tr>
<th style="text-align:left">事件</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onabort</td>
<td style="text-align:left">中断时触发</td>
</tr>
<tr>
<td style="text-align:left">onerror</td>
<td style="text-align:left">出错时触发</td>
</tr>
<tr>
<td style="text-align:left">onload</td>
<td style="text-align:left">文件读取成功完成时触发</td>
</tr>
<tr>
<td style="text-align:left">onloadend</td>
<td style="text-align:left">读取完成触发，无论成功或失败</td>
</tr>
<tr>
<td style="text-align:left">onloadstart</td>
<td style="text-align:left">读取开始时触发</td>
</tr>
<tr>
<td style="text-align:left">onprogress</td>
<td style="text-align:left">读取中</td>
</tr>
</tbody>
</table>
<p>文件一旦开始读取，无论成功或失败，实例的 result 属性都会被填充。如果读取失败，则 result 的值为 null ，否则即是读取的结果，绝大多数的程序都会在成功读取文件的时候，抓取这个值。</p>
<pre><code>var reader = new FileReader();
reader.onload = function() {  
    this.result;  
};
</code></pre><p><em>ps</em> 可以利用这些事件制作文件读取的进度条，此处不详细展开，有空在做补充。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/17/git子模块/" itemprop="url">
                  git子模块
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-17T15:31:17+08:00" content="2016-09-17">
              2016-09-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index">
                    <span itemprop="name">git</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="git子模块"><a href="#git子模块" class="headerlink" title="git子模块"></a>git子模块</h1><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在开发项目A时，需要依赖项目B（实时更新）。同时希望A,B能够独立处理。</p>
<h3 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h3><p>举例来说，现在我参与的项目<strong>网易有数（Youdata）</strong>，它依赖了一个独立开发的图形库<strong>NEV</strong>，他们是并行开发的。如果只是简单的将<strong>NEV</strong>的代码copy到Youdata中，显然是有点傻逼，因为无法自动更新NEV的迭代。</p>
<h3 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h3><p>Git 通过子模块处理这个问题。子模块允许你将一个 Git仓库当作另外一个Git仓库的子目录。这允许你克隆另外一个仓库到你的项目中并且保持你的提交相对独立。</p>
<h3 id="子模块相关操作："><a href="#子模块相关操作：" class="headerlink" title="子模块相关操作："></a>子模块相关操作：</h3><h4 id="1-添加子模块-git-submodule-add-url-path"><a href="#1-添加子模块-git-submodule-add-url-path" class="headerlink" title="1.添加子模块 $ git submodule add [url] [path]"></a>1.添加子模块 <code>$ git submodule add [url] [path]</code></h4><p>如</p>
<pre><code>$ git sub module add https://git.hz.netease.com/git/NEV/NEV.git src/webapp/res/nev
</code></pre><p>操作成功之后会生成一个.submodules的文件，其中记录了每个submodule的引用信息，知道在当前项目的位置以及仓库的所在。</p>
<h4 id="2-查看子模块-git-submodule"><a href="#2-查看子模块-git-submodule" class="headerlink" title="2.查看子模块 $ git submodule"></a>2.查看子模块 <code>$ git submodule</code></h4><p>如图</p>
<p><img src="./images/git子模块/1.png" alt=""></p>
<p>ps: 如果子模块前面有一个-，说明子模块文件还未检入（空文件夹）</p>
<h4 id="3-初始化子模块：-git-submodule-init-—-在首次检出仓库时运行一次"><a href="#3-初始化子模块：-git-submodule-init-—-在首次检出仓库时运行一次" class="headerlink" title="3.初始化子模块： $ git submodule init — 在首次检出仓库时运行一次"></a>3.初始化子模块： <code>$ git submodule init</code> — 在首次检出仓库时运行一次</h4><h4 id="4-更新子模块：-git-submodule-update"><a href="#4-更新子模块：-git-submodule-update" class="headerlink" title="4. 更新子模块：$ git submodule update"></a>4. 更新子模块：<code>$ git submodule update</code></h4><p>这个命令才是最常用的，每次子模块更新或者切换分支了，就执行一次。</p>
<h4 id="5-删除子模块："><a href="#5-删除子模块：" class="headerlink" title="5. 删除子模块："></a>5. 删除子模块：</h4><ul>
<li><code>$ git rm -cached [path]</code></li>
<li>编辑<code>.gitmodules</code>文件，删除对应的子模块配置</li>
<li>编辑<code>.git/config</code>文件，删除对应的子模块配置</li>
<li>最后删除子模块的目录</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/14/图解密码技术总结/" itemprop="url">
                  图解密码技术总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-14T15:42:58+08:00" content="2016-09-14">
              2016-09-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/书/" itemprop="url" rel="index">
                    <span itemprop="name">书</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="《图解密码技术》总结"><a href="#《图解密码技术》总结" class="headerlink" title="《图解密码技术》总结"></a>《图解密码技术》总结</h1><h3 id="一-历史上的密码"><a href="#一-历史上的密码" class="headerlink" title="一. 历史上的密码"></a>一. 历史上的密码</h3><h5 id="1-1-凯撒密码："><a href="#1-1-凯撒密码：" class="headerlink" title="1.1. 凯撒密码："></a>1.1. <strong>凯撒密码</strong>：</h5><ul>
<li>将明文按照字母表进行一定的“平移”来进行加密的加密算法。</li>
</ul>
<p><img src="./images/图解密码技术总结/1.1.png" alt=""></p>
<h5 id="1-2-简单替换密码："><a href="#1-2-简单替换密码：" class="headerlink" title="1.2. 简单替换密码："></a>1.2. <strong>简单替换密码</strong>：</h5><ul>
<li>两套字母表进行乱序一一对应，那么无论哪种对应关系都可以作为密码来使用。这种将明文中用到的字母表替换成另一套字母表的密码就是简单替换密码（simple substitution cipher）。如下图。</li>
</ul>
<p><img src="./images/图解密码技术总结/1.2.png" alt=""></p>
<h5 id="1-3-Enigma："><a href="#1-3-Enigma：" class="headerlink" title="1.3. Enigma："></a>1.3. <strong>Enigma</strong>：</h5><ul>
<li>相信很多人看过由卷福饰演图灵的电影《模仿游戏》，那么对于二战时期大名鼎鼎的德国密码机Enigma一定不陌生了。</li>
<li>Enigma在德语中的意思就是“谜”。</li>
<li>发明之初是作为商用的，到了纳粹时期，经过改良后用于军事用途。</li>
<li>Enigma是一种由键盘、齿轮、电池和灯泡组成的机器。通过一台机器可以完成加密解密两种操作。</li>
<li>其实<strong>Enigma相当于一个密码算法</strong>， 它并不依赖于<strong>隐蔽式安全性</strong>（security by obscurity）—隐蔽式安全性：顾名思义就是依靠算法的隐蔽性来获得安全保障，一旦算法被曝光就会被破解。而Enigma密码机就算被密码破译者得到，只要不知道Enigma的设置（相当于密钥），就无法破译密码。</li>
</ul>
<h6 id="1-3-1-下图为Enigma进行加密通信的过程图。"><a href="#1-3-1-下图为Enigma进行加密通信的过程图。" class="headerlink" title="1.3.1 下图为Enigma进行加密通信的过程图。"></a>1.3.1 下图为Enigma进行加密通信的过程图。</h6><p><img src="./images/图解密码技术总结/1.3.png" alt=""></p>
<h6 id="1-3-2-Enigma加密"><a href="#1-3-2-Enigma加密" class="headerlink" title="1.3.2 Enigma加密"></a>1.3.2 Enigma加密</h6><p>下图为Enigma进行加密nacht的过程图。</p>
<p><img src="./images/图解密码技术总结/1.4.png" alt=""></p>
<p>在进行通信之前，发送者和接受者都需要持有国防军密码本，这里面记载了发送者和接受者需要使用的每日密码。如果有一本国防军密码本被缴获，那就需要全部替换新的密码本。这里就涉及到密钥的配送问题。</p>
<ol>
<li><p>设置Enigma</p>
<p> 发送者查阅国防军密码本，找到当天的<strong>每日密码</strong>，并按照该密码设置Enigma。</p>
</li>
<li><p>加密通信密码</p>
<p> 接下来，发送者需要想出3个字母（这里假设为psv），并将其加密。这3个字母称为<strong>通信密码</strong>。</p>
<p> 由于Enigma的时代，无线电的质量很差，可能发生通信错误。所以通信密码需要连续输入两次（psvpsv），以便接受者可以进行校验。在Enigma中输入psvpsv这6个字母，则会得到对应的密文并记录，假设密文为ATCDVT（密文用大写字母表示）。</p>
<p> 这里可以看出，每日密码其实是用来加密通信密钥的密钥。这样的密钥，一般称为<strong>密钥加密密钥</strong>（Key Encryptiong Key，KEK）。</p>
</li>
<li><p>重新设置Enigma</p>
<p> 此时，根据通信密码（psv）重新设置Enigma。</p>
</li>
<li><p>加密信息</p>
<p> 接下来，发送者就可以对消息进行加密了。假设消息（明文）为nacht，进过加密得到KXNWP。</p>
</li>
<li><p>拼接</p>
<p> 最后，将2中得到的通信密码“ATCDVT”与加密后的消息“KXNWP”进行拼接，将“ATCDVTKXNWP”作为电文通过无线电发送出去。</p>
</li>
</ol>
<h6 id="1-3-3-Enigma解密"><a href="#1-3-3-Enigma解密" class="headerlink" title="1.3.3 Enigma解密"></a>1.3.3 Enigma解密</h6><p>理解了加密步骤，解密就简单了。</p>
<ul>
<li>首先将密文分成两部分，即开头6个字母ATCDVT和剩下的字母KXNWP。</li>
<li>根据和发送者相同的每日密码设置Enigma。将ATCDVT破译得到psvpsv。</li>
<li>根据psv设置Enigma。</li>
<li>然后破译剩下的字母KXNWP，得到明文nacht。</li>
</ul>
<h6 id="1-3-4-Enigma的弱点"><a href="#1-3-4-Enigma的弱点" class="headerlink" title="1.3.4 Enigma的弱点"></a>1.3.4 Enigma的弱点</h6><ul>
<li>通信密码连续输入两次。</li>
<li>通信密码人为选定。理论上通信密码应该具有不可预测性。</li>
<li>必须派发国防军密码本。前面也说了，如果泄露一本，就需要全部替换新的。</li>
</ul>
<p>===</p>
<h3 id="二-对称密码"><a href="#二-对称密码" class="headerlink" title="二. 对称密码"></a>二. 对称密码</h3><ul>
<li>所谓对称密码，就是说加密和解密使用的是相同的密钥。</li>
<li>算法的核心是利用位运算中“异或”的方式来实现的。简单的讲：“01”组成的比特序列经过与密钥的一次“异或”<br>即可得到密文，再和相同的密钥进行一次“异或”就能还原明文。</li>
<li>对称密码的算法：DES、三重DES、AES（AES的标准所选定的密码算法叫作Rijndael）。</li>
</ul>
<h4 id="2-1-一次性密码本-—-绝对不会被破译的密码"><a href="#2-1-一次性密码本-—-绝对不会被破译的密码" class="headerlink" title="2.1 一次性密码本 — 绝对不会被破译的密码"></a>2.1 一次性密码本 — 绝对不会被破译的密码</h4><ul>
<li>原理是： 将明文和一串随机的比特序列进行XOR运算。</li>
<li>那么为什么它是无法破译的呢：无法破译并不是说不能解出明文，而是说无法判断它是否是正确的明文，因为在解密的过程（暴力破解）中所有的排列组合都会出现，因此就无法判断哪一个才是正确的明文。</li>
</ul>
<p>===</p>
<h3 id="三-公钥密码—用公钥加密，用私钥解密"><a href="#三-公钥密码—用公钥加密，用私钥解密" class="headerlink" title="三. 公钥密码—用公钥加密，用私钥解密"></a>三. 公钥密码—用公钥加密，用私钥解密</h3><ul>
<li>书里关于投币寄存柜的比喻很好：钱是关闭寄存柜的密钥，钥匙是打开寄存柜的密钥。类比公钥密码，钱就是公钥，谁都可以用来加密寄存柜，但是要打开寄存柜只能用私钥“钥匙”。</li>
</ul>
<h4 id="3-1-密钥配送问题"><a href="#3-1-密钥配送问题" class="headerlink" title="3.1 密钥配送问题"></a>3.1 密钥配送问题</h4><p>如果密钥如同密文一样通过网络直接发送，那么也很容易被窃听。那么如何解决这个问题呢。</p>
<ul>
<li>通过事先共享的密钥来解决。</li>
<li>通过密钥分配中心来解决。</li>
<li>通过Diffie-Hellman密钥交换来解决。</li>
<li>通过公钥密码来解决。</li>
</ul>
<h4 id="3-2-那么如何通过公钥密钥来解决密钥配送问题呢"><a href="#3-2-那么如何通过公钥密钥来解决密钥配送问题呢" class="headerlink" title="3.2 那么如何通过公钥密钥来解决密钥配送问题呢"></a>3.2 那么如何通过公钥密钥来解决密钥配送问题呢</h4><h5 id="3-2-1-首先来介绍下公钥的通信流程"><a href="#3-2-1-首先来介绍下公钥的通信流程" class="headerlink" title="3.2.1 首先来介绍下公钥的通信流程"></a>3.2.1 首先来介绍下公钥的通信流程</h5><ol>
<li>Bob生成一个包含公钥和私钥的密钥对。私钥有Bob自己保管。</li>
<li>Bob将公钥发送给Alice。Bob的公钥被窃听者Eve获取也没关系。将公钥发送给Alice表示让他用这个公钥加密消息并发送给Bob。</li>
<li>Alice用Bob的公钥加密消息，加密后的消息只能用Bob的私钥才能解密。Alice的公钥是无法解密的。</li>
<li>Alice将密文发送给Bob。这样密文就算被窃听也没有关系。</li>
<li>Bob用私钥进行解密。</li>
</ol>
<p><img src="./images/图解密码技术总结/3.1.png" alt=""></p>
<h5 id="3-2-2-解决密钥配送问题"><a href="#3-2-2-解决密钥配送问题" class="headerlink" title="3.2.2 解决密钥配送问题"></a>3.2.2 解决密钥配送问题</h5><p>因此，我们可以用公钥来加密对称密码的密钥，从而解决密钥配送的问题。</p>
<h5 id="3-2-3-公钥密码无法解决的问题"><a href="#3-2-3-公钥密码无法解决的问题" class="headerlink" title="3.2.3 公钥密码无法解决的问题"></a>3.2.3 公钥密码无法解决的问题</h5><ol>
<li>公钥密码的速度只有对称密码的几百分之一。速度问题如何解决。</li>
<li>如何判断公钥的正确合法性，这个问题是公钥认证的问题。举例：<strong>中间人攻击</strong>，如图</li>
</ol>
<p><img src="./images/图解密码技术总结/3.2.png" alt=""></p>
<h5 id="3-2-4-公钥密码的算法"><a href="#3-2-4-公钥密码的算法" class="headerlink" title="3.2.4 公钥密码的算法"></a>3.2.4 公钥密码的算法</h5><ul>
<li>算法的核心是利用mod运算（取余运算）</li>
<li>简单介绍下现在使用最广泛的公钥密码算法 — RSA<ul>
<li>密文 = 明文 E MOD N （RSA加密：明文的E次方除以N的余数）</li>
<li>明文 = 密文 D MOD N （RSA解密：密文的D次方除以N的余数）</li>
<li>E和N的组合就是公钥</li>
<li>D和N的组合就是私钥</li>
</ul>
</li>
</ul>
<p>===</p>
<h3 id="四-混合密码系统-—-用对称密码提高速度，用公钥密码保护会话密钥"><a href="#四-混合密码系统-—-用对称密码提高速度，用公钥密码保护会话密钥" class="headerlink" title="四. 混合密码系统 — 用对称密码提高速度，用公钥密码保护会话密钥"></a>四. 混合密码系统 — 用对称密码提高速度，用公钥密码保护会话密钥</h3><p>在3.2.3中提到公钥密码还有两个很大的问题。一是速度问题，二是认证问题。这一节介绍的混合密码系统可以解决第一个速度问题。第二个问题在后面的小节中介绍。</p>
<h4 id="4-1-混合密码系统组成"><a href="#4-1-混合密码系统组成" class="headerlink" title="4.1 混合密码系统组成"></a>4.1 混合密码系统组成</h4><ul>
<li>用对称密码加密消息</li>
<li>通过伪随机数生成器生成对称密码加密中使用的会话秘钥</li>
<li>用公钥密码加密会话密钥(这就是解决速度问题的方法，因为对称密码的密钥一般比消息本身要短)</li>
<li>从混合密码系统外部赋予公钥密码加密时使用的密钥</li>
</ul>
<h4 id="4-2-混合密码系统的加密过程"><a href="#4-2-混合密码系统的加密过程" class="headerlink" title="4.2 混合密码系统的加密过程"></a>4.2 混合密码系统的加密过程</h4><p><img src="./images/图解密码技术总结/4.1.png" alt=""></p>
<h4 id="4-3-混合密码系统的解密过程"><a href="#4-3-混合密码系统的解密过程" class="headerlink" title="4.3 混合密码系统的解密过程"></a>4.3 混合密码系统的解密过程</h4><p><img src="./images/图解密码技术总结/4.2.png" alt=""></p>
<p>===<br>认证部分</p>
<p>===</p>
<h3 id="五-单向散列函数-—-获取消息的“指纹”"><a href="#五-单向散列函数-—-获取消息的“指纹”" class="headerlink" title="五. 单向散列函数 — 获取消息的“指纹”"></a>五. 单向散列函数 — 获取消息的“指纹”</h3><h4 id="5-1-什么是单向散列值（one-way-hash-function）"><a href="#5-1-什么是单向散列值（one-way-hash-function）" class="headerlink" title="5.1 什么是单向散列值（one-way hash function）"></a>5.1 什么是单向散列值（one-way hash function）</h4><ul>
<li>单向散列函数可以根据消息的内容计算出<strong>固定长度</strong>的散列值，用于验证消息的<strong>完整性</strong>。</li>
</ul>
<h4 id="5-2-单向散列函数的性质"><a href="#5-2-单向散列函数的性质" class="headerlink" title="5.2 单向散列函数的性质"></a>5.2 单向散列函数的性质</h4><ul>
<li>根据任意长度的消息计算出固定长度的散列值。</li>
<li>能够<strong>快速</strong>计算出散列值。</li>
<li>消息不同散列值不同。<ul>
<li><strong>弱</strong>抗碰撞性：要找到和该条消息具有相同散列值的另一条消息是非常困难的。</li>
<li><strong>强</strong>抗碰撞性：要找到散列值相同的两条不同的消息是非常困难的。</li>
</ul>
</li>
<li>具备单向性</li>
</ul>
<h4 id="5-3-单向散列函数的实际应用"><a href="#5-3-单向散列函数的实际应用" class="headerlink" title="5.3 单向散列函数的实际应用"></a>5.3 单向散列函数的实际应用</h4><ol>
<li><strong>检测软件是否被篡改</strong></li>
<li><strong>基于口令的加密</strong>（Password Based Encryption，PBE）：将口令和盐（salt，通过伪随机数生成器产生的随机值）混合后计算其散列值，然后将这个散列值用作加密的密钥。这样做可以防御针对口令的字典攻击。</li>
<li><strong>消息认证码</strong>：消息认证码是将“发送者和接受者之间的共享密钥”和“消息”进行混合计算出的散列值。使用消息认证码可以检测并防止通信过程中的错误、篡改以及伪装。</li>
<li><strong>数字签名</strong>：数字签名一般是通过单向散列函数计算出消息的散列值，然后在这个散列值上施加数字签名。</li>
<li><strong>伪随机数生成器</strong></li>
<li><strong>一次性口令</strong>：常被用于服务器对客户端的合法性认证。</li>
</ol>
<h4 id="5-4-单向散列函数的具体例子"><a href="#5-4-单向散列函数的具体例子" class="headerlink" title="5.4 单向散列函数的具体例子"></a>5.4 单向散列函数的具体例子</h4><ol>
<li>MD4、MD5</li>
<li>SHA-1、SHA-256、SHA-384、SHA-512</li>
<li>RIPEMD-160</li>
</ol>
<p>===</p>
<h3 id="六-消息认证码-—-消息被正确传送了吗"><a href="#六-消息认证码-—-消息被正确传送了吗" class="headerlink" title="六. 消息认证码 — 消息被正确传送了吗"></a>六. 消息认证码 — 消息被正确传送了吗</h3><h4 id="6-1-什么是消息认证码"><a href="#6-1-什么是消息认证码" class="headerlink" title="6.1 什么是消息认证码"></a>6.1 什么是消息认证码</h4><ul>
<li>消息认证码（message authentication code）是一种确认完整性并进行认证的技术，取三个单词的首字母，简称MAC。</li>
<li>消息认证码是输入包括任意长度的消息和一个发送者和接收者之间共享的密钥，它可以输出固定长度的数据，这个数据成为MAC值。</li>
<li>消息认证码是一种与密钥相关的单向散列函数。如下图</li>
</ul>
<p><img src="./images/图解密码技术总结/6.1.png" alt=""></p>
<h4 id="6-2-消息认证码的使用步骤图"><a href="#6-2-消息认证码的使用步骤图" class="headerlink" title="6.2 消息认证码的使用步骤图"></a>6.2 消息认证码的使用步骤图</h4><p><img src="./images/图解密码技术总结/6.2.png" alt=""></p>
<h4 id="6-3-消息认证码的密钥的配送问题"><a href="#6-3-消息认证码的密钥的配送问题" class="headerlink" title="6.3 消息认证码的密钥的配送问题"></a>6.3 消息认证码的密钥的配送问题</h4><p>看上图就知道，共享密钥的配送问题依旧存在。解决方法也和对称密码差不多，例如公钥密码，Diffie-Hellman密钥交换等，具体项目具体安排。</p>
<h4 id="6-4-消息认证码的应用实例"><a href="#6-4-消息认证码的应用实例" class="headerlink" title="6.4 消息认证码的应用实例"></a>6.4 消息认证码的应用实例</h4><ol>
<li>SWIFT</li>
<li>IPsec</li>
<li>SSL/TLS</li>
</ol>
<h4 id="6-5-对消息认证码的攻击"><a href="#6-5-对消息认证码的攻击" class="headerlink" title="6.5 对消息认证码的攻击"></a>6.5 对消息认证码的攻击</h4><ol>
<li>重放攻击</li>
<li>密钥推测攻击</li>
</ol>
<h4 id="6-6-消息认证码无法解决的问题"><a href="#6-6-消息认证码无法解决的问题" class="headerlink" title="6.6 消息认证码无法解决的问题"></a>6.6 消息认证码无法解决的问题</h4><ol>
<li>对第三方证明。第三方无法知道消息来自A,B哪一方。（数字签名可以证明）</li>
<li>防止否认。（数字签名可以防止否认）</li>
</ol>
<p>===</p>
<h3 id="七-数字签名-—-消息到底是谁写的"><a href="#七-数字签名-—-消息到底是谁写的" class="headerlink" title="七. 数字签名 — 消息到底是谁写的"></a>七. 数字签名 — 消息到底是谁写的</h3><ul>
<li>数字签名可以识别篡改和伪装，还可以防止否认。</li>
<li>数字签名可以看成是公钥密码的<strong>反用</strong>，如图</li>
</ul>
<p>公钥密码与数字签名的密钥使用方式<br><img src="./images/图解密码技术总结/7.1.png" alt=""> </p>
<p>公钥密码<br><img src="./images/图解密码技术总结/7.2.png" alt=""> </p>
<p>数字签名<br><img src="./images/图解密码技术总结/7.3.png" alt=""> </p>
<h4 id="7-1-数字签名的方法"><a href="#7-1-数字签名的方法" class="headerlink" title="7.1 数字签名的方法"></a>7.1 数字签名的方法</h4><ul>
<li>直接对消息签名的方法</li>
<li>对消息的散列值签名的方法（常用）</li>
</ul>
<h4 id="7-2-实际应用"><a href="#7-2-实际应用" class="headerlink" title="7.2 实际应用"></a>7.2 实际应用</h4><ol>
<li>安全信息公告：一些信息安全方面的组织会在其网站上发布一些安全漏洞的警告，那么如何验证这些警告信息真的是这个组织发布的呢？此时就可以用数字签名。</li>
<li>软件下载</li>
<li>公钥证书：用于验证公钥的合法性。</li>
<li>SSL/TLS</li>
</ol>
<h4 id="7-3-通过RSA实现数字签名"><a href="#7-3-通过RSA实现数字签名" class="headerlink" title="7.3 通过RSA实现数字签名"></a>7.3 通过RSA实现数字签名</h4><ul>
<li>签名 = 消息 D MOD N (消息的D次方除以N取余数)</li>
<li>由签名求得的消息 = 签名 E MOD N （签名的E次方除以N取余数）</li>
<li>D和N就是签名者的私钥</li>
<li>E和N就是签名者的公钥</li>
</ul>
<h4 id="7-4-对数字签名的攻击"><a href="#7-4-对数字签名的攻击" class="headerlink" title="7.4 对数字签名的攻击"></a>7.4 对数字签名的攻击</h4><ol>
<li>中间人攻击。（可以通过公钥证书来防止）</li>
<li>对单向散列函数的攻击</li>
<li>利用数字签名攻击公钥密码</li>
</ol>
<h4 id="7-5-各类密码技术的对比"><a href="#7-5-各类密码技术的对比" class="headerlink" title="7.5 各类密码技术的对比"></a>7.5 各类密码技术的对比</h4><p><img src="./images/图解密码技术总结/7.4.png" alt=""> </p>
<p>===</p>
<h3 id="八-证书-—-为公钥加上数字签名"><a href="#八-证书-—-为公钥加上数字签名" class="headerlink" title="八 证书 — 为公钥加上数字签名"></a>八 证书 — 为公钥加上数字签名</h3><h4 id="8-1-什么是证书"><a href="#8-1-什么是证书" class="headerlink" title="8.1 什么是证书"></a>8.1 什么是证书</h4><p>公钥证书（Public-Key Certificae，PKC）：里面记有姓名、组织、邮箱地址等个人信息，以及属于此人的<strong>公钥</strong>，并由<strong>认证机构</strong>（Certification Authority、Certifying Authority， CA）施加数字签名。只要看到公钥证书，我们就可以知道认证机构认定该公钥的确属于此人。公钥证书简称为证书（certificate）</p>
<h4 id="8-2-证书的应用场景"><a href="#8-2-证书的应用场景" class="headerlink" title="8.2 证书的应用场景"></a>8.2 证书的应用场景</h4><p><img src="./images/图解密码技术总结/8.1.png" alt=""> </p>
<h4 id="8-3-公钥基础设施（PKI）"><a href="#8-3-公钥基础设施（PKI）" class="headerlink" title="8.3 公钥基础设施（PKI）"></a>8.3 公钥基础设施（PKI）</h4><p>就是为了能够更有效的运用公钥而制定的一系列规范和规格的总称。</p>
<p>组成要素：</p>
<ul>
<li>用户 — 使用PKI的人</li>
<li>认证机构 — 颁发证书的人</li>
<li>仓库 — 保存证书的数据库</li>
</ul>
<p>===</p>
<h3 id="九-随机数-—-不可预测性的源泉"><a href="#九-随机数-—-不可预测性的源泉" class="headerlink" title="九 随机数 — 不可预测性的源泉"></a>九 随机数 — 不可预测性的源泉</h3><h4 id="9-1-随机数的性质"><a href="#9-1-随机数的性质" class="headerlink" title="9.1 随机数的性质"></a>9.1 随机数的性质</h4><ul>
<li>随机性 — 不存在统计学偏差，是完全杂乱的数列。（弱伪随机数）</li>
<li>不可预测性 — 不能从过去的数列推测出下一个出现的数。（强伪随机数）</li>
<li><p>不可重现性 — 除非将数列本身保存下来，否则不能重现相同的数列。（真随机数）</p>
<p>  上面三种性质中，越往下越严格。</p>
</li>
</ul>
<p><img src="./images/图解密码技术总结/9.1.png" alt=""> </p>
<ul>
<li>对于软件所生成的数列，周期必定是有限的。凡是有限周期的数列，都不具备不可重现性。</li>
<li>要生成不可重现的随机书里额，需要从不可重现的物理现象中获取信息。</li>
</ul>
<p>===</p>
<h3 id="十-SSL-TLS-—-为了更安全的通信"><a href="#十-SSL-TLS-—-为了更安全的通信" class="headerlink" title="十 SSL/TLS — 为了更安全的通信"></a>十 SSL/TLS — 为了更安全的通信</h3><h4 id="10-1-什么是SSL-TLS"><a href="#10-1-什么是SSL-TLS" class="headerlink" title="10.1 什么是SSL/TLS"></a>10.1 什么是SSL/TLS</h4><ul>
<li>是目前世界上最广泛的密码通信方法。</li>
<li>综合运用了前面提到的技术：对称密码、消息认证码、公钥密码、数字签名、伪随机数生成器等密码技术。</li>
</ul>
<p>===</p>
<h3 id="十一-密码技术与现实社会"><a href="#十一-密码技术与现实社会" class="headerlink" title="十一 密码技术与现实社会"></a>十一 密码技术与现实社会</h3><h4 id="11-1-密码学家的工具箱"><a href="#11-1-密码学家的工具箱" class="headerlink" title="11.1 密码学家的工具箱"></a>11.1 密码学家的工具箱</h4><p><img src="./images/图解密码技术总结/11.1.png" alt=""></p>
<h4 id="11-2-密码技术与压缩技术"><a href="#11-2-密码技术与压缩技术" class="headerlink" title="11.2 密码技术与压缩技术"></a>11.2 密码技术与压缩技术</h4><p><img src="./images/图解密码技术总结/11.2.png" alt=""></p>
<ul>
<li>密钥是机密性的精华</li>
<li>散列值是完整性的精华</li>
<li>认证符号（MAC值和签名）是认证的精华</li>
<li>种子是不可预测性的精华</li>
</ul>
<p><img src="./images/图解密码技术总结/11.3.png" alt=""></p>
<h4 id="11-3-只有完美的密码，没有完美的人"><a href="#11-3-只有完美的密码，没有完美的人" class="headerlink" title="11.3 只有完美的密码，没有完美的人"></a>11.3 只有完美的密码，没有完美的人</h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/04/不同unicode编码的空格挖的坑/" itemprop="url">
                  不同unicode编码的空格挖的坑
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-04T17:33:14+08:00" content="2016-08-04">
              2016-08-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前段时间在做搜索的时候，遇到一个关于空格的小问题，总结一下。</p>
<p>有时在文本值中会插入一些空格字符 （Unicode 字符集值 32 和 160） ，比如说标题之类的。当你对包含空格的值进行<strong>排序、 筛选或搜索</strong>时，这些字符有时会导致意外的结果。本次就是因为把数据存放在dom节点上，取出来做搜索的时候，发现编码发现了改变（从32变成了160），导致无法正确匹配。</p>
<blockquote>
<p>The non-breaking space (U+00A0 Unicode, 160 decimal, &nbsp;) is not the same as the space character (U+0020 Unicode, 32 decimal). Well, both of them seems to be a “space”, but they are absolutely different characters.</p>
</blockquote>
<p>这里的解决方案是：采用正则替换成统一字符，如下</p>
<pre><code>var s = &apos; &apos; // 假设这里是一个160的空格。
var reg = new RegExp(String.fromCharCode(160),&quot;gm&quot;);
var 32sp = String.fromCharCode(32)
s = s.replace(reg, 32sp);
</code></pre><p>后来重构代码，直接废除了将数据存在dom上这种方案，就更好了。</p>
<p>除了空格字符，非打印字符在进行<strong>排序、 筛选或搜索</strong>操作时，也可能会遇到这类问题，<a href="https://support.office.com/zh-cn/article/%E5%88%A0%E9%99%A4%E6%96%87%E6%9C%AC%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC%E5%92%8C%E9%9D%9E%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6-023f3a08-3d56-49e4-bf0c-fe5303222c9d" target="_blank" rel="external">参考</a>。要注意~</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/04/鼠标跟随旋转效果实现/" itemprop="url">
                  鼠标跟随旋转效果实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-04T00:30:11+08:00" content="2016-08-04">
              2016-08-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/CSS/" itemprop="url" rel="index">
                    <span itemprop="name">CSS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="鼠标跟随的3D转动"><a href="#鼠标跟随的3D转动" class="headerlink" title="鼠标跟随的3D转动"></a>鼠标跟随的3D转动</h3><p>首先，甩一枚简单的<a href="http://runjs.cn/detail/1hnseaw3" target="_blank" rel="external">demo</a>看下要实现的效果。点击右下角可查看源码。</p>
<p>ok，直接开干，这个demo里面主要用到了两个属性：<code>transform</code>和<code>perspective</code>。分别可以设置3D和透视投影的效果。</p>
<h3 id="3D变换效果"><a href="#3D变换效果" class="headerlink" title="3D变换效果"></a>3D变换效果</h3><p>首先介绍下<code>transform</code>，写过一丢丢动画的孩子都会接触过的属性。<code>CSS3</code>的3D效果是使用<code>transform</code>的<code>rotateX(Y, Z)</code>，<code>translateX(Y, Z)</code>，<code>scaleX(Y, Z)</code>方法进行设置的。</p>
<p><img src="./images/鼠标跟随旋转效果实现/坐标.png" alt=""></p>
<p>上图就是一个3D坐标系，需要注意的是，3D元素的原点应该是在元素的中心，而不是像上图一样在立方体的一个角上。如果只是单单一个元素的话，它的形状就是一个平面区域。下面简单介绍一下<code>transform</code>中相关的3D方法。</p>
<h5 id="rotateX-Y-Z"><a href="#rotateX-Y-Z" class="headerlink" title="rotateX(Y, Z)"></a>rotateX(Y, Z)</h5><p>顾名思义就是绕着X轴（Y轴或者Z轴）旋转。注意：<strong>逆时针为正方向</strong>（如图）</p>
<h5 id="translateX-Y-Z"><a href="#translateX-Y-Z" class="headerlink" title="translateX(Y, Z)"></a>translateX(Y, Z)</h5><p>默认情况下，开启的是平面投影，所以此时设置<code>translateZ</code>是没有什么luan用的。那怎么生效呢，看下去才告诉你（╭(╯^╰)╮）。</p>
<h5 id="scaleX-Y-Z"><a href="#scaleX-Y-Z" class="headerlink" title="scaleX(Y, Z)"></a>scaleX(Y, Z)</h5><p>缩放，好理解。偶尔会用来做字号的特殊处理，比如像chrome默认的最小字号是<code>12px</code>，要是你家视觉非要设置<code>10px</code>大小的字体咋整，那就给他一巴掌，叫他要求这么多（现实情况是可以用这个属性来解决……）。</p>
<p>题外话：chrome的默认最小字号可以在设置中更改，不过你的用户可不管这些。</p>
<hr>
<h5 id="transform-style属性"><a href="#transform-style属性" class="headerlink" title="transform-style属性"></a>transform-style属性</h5><p>它有两个值：</p>
<ul>
<li><code>flat</code>(默认，顾名思义就是平面状态，所以上面说的设置translateZ才会失效。)</li>
<li><code>preserve-3d</code></li>
</ul>
<p>聪明如你马上明白<code>preserve-3d</code>才是主角，设置了<code>transform-style: preserve-3d</code>的父元素会生成一个3D空间，把所有的<strong>子元素</strong>都包括在这个3D空间内。</p>
<p><strong>注意</strong>：上面说的是<strong>子元素</strong> ，不是<strong>后代元素</strong>，看看demo中的<code>我是preserve-3d的孙子</code>这行字所在的元素，Z值和它爸爸<code>黑月</code>是不同的，但是转动卡片发现，视觉效果上他们是在同一个Z值平面的。那要让孙子上的Z值也生效呢？啥，你还不知道！那你再看一遍上面的两段话- -。（答案：在<code>黑月</code>上再设置一次这个属性，可以在demo上尝试修改下看看）。</p>
<p>对于父元素设置的<code>transform</code>属性，都会应用到生成的这个3D空间，对整个空间进行3D操作（旋转，平移，缩放）。最后会把所有的元素投影到<code>屏幕</code>上，不是父元素上！</p>
<p>当<code>transform-style</code>的值为<code>flat</code>时，子元素和父元素是互相独立的，并没有在父元素的3D空间内，他们各自做各自的3D变换，然后<strong>按照先后顺序</strong>投影到父元素上。这也是<code>flat</code>时，translateZ失效的原因。</p>
<p><strong>tips</strong>：设置在transform属性上的<code>rotateX(Y, Z)</code>，<code>translateX(Y, Z)</code>，<code>scaleX(Y, Z)</code>方法是从右向左执行的。</p>
<hr>
<h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><p>透视投影是模拟人眼的图像观察方式，让平面上的物体呈现现实的视觉效果。</p>
<p>有两种设置方式：</p>
<ul>
<li><code>perspective: none | &lt;length&gt;;</code></li>
<li><code>transform: perspective(&lt;length&gt;) method(p) method(p) ...;</code></li>
</ul>
<p>第一种：可以将<strong>子元素</strong>(不包含自身，不包括后代元素)的投影效果设置为透视投影。<br>第二种：为这个元素自身开启透视投影模式。</p>
<p>先看下<strong>3D视角</strong>的原理图，来自<a href="https://css-tricks.com/tour-performant-responsive-css-site/" target="_blank" rel="external">这里</a></p>
<p><img src="./images/鼠标跟随旋转效果实现/透视原理图.png" alt=""></p>
<p>图中淡蓝色部分即电脑屏幕所在的平面（z=0的平面），眼睛所在的位置就是通过<code>perspective</code>设置的模拟焦点位置，焦点到z=0平面的距离就是<code>perspective</code>的值，而橘红色部分就是设置了<code>translateZ</code>为负值的3D元素的所在平面，3D元素到z=0平面的距离就是3D元素上<code>translateZ</code>的值，如图为负值，如果在焦点和z=0及平面之间，则为正值。</p>
<p>这是透视的<strong>平面</strong>原理图，来自<a href="https://segmentfault.com/a/1190000003843764" target="_blank" rel="external">这里</a>。<br><img src="./images/鼠标跟随旋转效果实现/透视原理图-平面.png" alt=""></p>
<p>通过这两张图，应该能够很直观的看出<code>perspective</code>和<code>translateZ</code>的设置对于3D元素在屏幕上产生的投影的效果了。当元素的z值大于’perspective’的值时，你就看不见它了，就像你的boss站在你的脑袋后面一样一样。一般情况下，’perspective’设置500px到1000px在视觉上比较合理。</p>
<p>在<a href="http://runjs.cn/detail/1hnseaw3" target="_blank" rel="external">demo</a>中，如果取消<code>perspective</code>透视属性，你会发现，卡片就像一个没固定好的相框在转动，这就算是透视属性的必要性。</p>
<p>透视投影还可以设置焦点的位置（默认在中心），因为你的脑袋也是可以动的：</p>
<p><code>perspective-origin: x y;</code></p>
<p><strong>到这里，3d和透视投影的相关属性就介绍完了，有什么不清楚的你可以改改<a href="http://runjs.cn/detail/1hnseaw3" target="_blank" rel="external">demo</a>测试下。</strong></p>
<p>对不起，还没完……</p>
<hr>
<h3 id="鼠标跟随的实现"><a href="#鼠标跟随的实现" class="headerlink" title="鼠标跟随的实现"></a>鼠标跟随的实现</h3><p>关键是理清前面的属性，最后的鼠标跟随转动效果通过js实现应该比较简单了，监听<code>mousemove</code>事件，根据鼠标位置到3D元素的中心的<code>距离</code>，<code>除以</code>一定的<code>系数</code>，实时改变元素的<code>rotateX</code>和<code>rotateY</code>的值来达到效果。你可以通过改变<code>系数</code>的大小来控制<code>转动的灵敏度</code>。</p>
<p>贴一下代码：</p>
<pre><code>var o = $(&quot;#card&quot;);
$(&quot;#top&quot;).on(&quot;mousemove&quot;, function(t) {
    var e = -($(window).innerWidth() / 2 - t.pageX) / 20,
        n = ($(window).innerHeight() / 2 - t.pageY) / 10;
    o.attr(&quot;style&quot;,
        &quot;transform: rotateY(&quot; + e + &quot;deg) rotateX(&quot; + n + &quot;deg);
        -webkit-transform: rotateY(&quot; + e + &quot;deg) rotateX(&quot; + n + &quot;deg);
        -moz-transform: rotateY(&quot; + e + &quot;deg) rotateX(&quot; + n + &quot;deg)&quot;
    )
})
</code></pre><hr>
<p><strong> THE END……能看到这里的人真是让俺感动啊~</strong></p>
<p>养成好习惯，顺手打广告：这个动效用在了<a href="https://youdata.netease.com/" target="_blank" rel="external">网易有数</a>的首页。<strong>网易有数</strong>是一款敏捷数据分析平台，欢迎使用体验。</p>
<p>参考自：</p>
<ul>
<li><a href="https://css-tricks.com/tour-performant-responsive-css-site/" target="_blank" rel="external">Tour of a Performant and Responsive CSS Only Site</a></li>
<li><a href="https://segmentfault.com/a/1190000003843764" target="_blank" rel="external">3D效果 &amp; 透视</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/03/Hexo-GitHub-Pages-构建博客/" itemprop="url">
                  Hexo + GitHub Pages 构建博客
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-03T12:54:27+08:00" content="2016-08-03">
              2016-08-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/常规/" itemprop="url" rel="index">
                    <span itemprop="name">常规</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-介绍篇"><a href="#1-介绍篇" class="headerlink" title="1. 介绍篇"></a>1. 介绍篇</h2><p><a href="https://fenglai0802.github.io/" target="_blank" rel="external">DEMO</a></p>
<h4 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h4><p><a href="https://hexo.io/" target="_blank" rel="external">Hexo</a> 是一个简单地、轻量地、基于Node的一个静态博客框架，可以方便的生成静态网页。作者是台湾大学生tommy351。</p>
<h4 id="什么是GitHub-Pages"><a href="#什么是GitHub-Pages" class="headerlink" title="什么是GitHub Pages"></a>什么是GitHub Pages</h4><p><a href="https://pages.github.com/" target="_blank" rel="external">GitHub Pages</a> 可以被认为是用户编写的、托管在github上的静态网页。由于它的空间免费稳定， 可以用于介绍托管在github上的Project或者搭建网站。有两种形式: Project Site 和 User/Org Site。</p>
<p>GitHub Pages 生成的网站的默认域名是 username.github.io 或者 username.github.io/project-name ，但GitHub Pages是支持自定义域名的，参考教程：<a href="https://www.zhihu.com/question/31377141" target="_blank" rel="external">github怎么绑定自己的域名</a></p>
<h2 id="2-安装篇"><a href="#2-安装篇" class="headerlink" title="2. 安装篇"></a>2. 安装篇</h2><h4 id="安装中的一些小问题提醒"><a href="#安装中的一些小问题提醒" class="headerlink" title="安装中的一些小问题提醒"></a>安装中的一些小问题提醒</h4><ol>
<li>npm 报连接错误导致的安装失败：建议使用<a href="http://npm.taobao.org/" target="_blank" rel="external">淘宝NPM镜像</a>。</li>
<li>权限错误：命令前加sudo</li>
</ol>
<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><ul>
<li>安装node (建议采用<a href="https://fenglai0802.github.io/2016/08/03/%E5%88%A9%E7%94%A8%E6%A8%A1%E5%9D%97n%E7%AE%A1%E7%90%86node%E7%89%88%E6%9C%AC/" target="_blank" rel="external">n模块安装</a>)</li>
<li>安装git（安装Xcode自带）</li>
<li>申请github账号</li>
</ul>
<h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><ol>
<li><p>首先全局安装hexo</p>
<pre><code>$ npm install -g hexo
</code></pre></li>
</ol>
<ol>
<li><p>创建工作文件夹，举例命名为<code>blog</code>;</p>
</li>
<li><p>进入<code>blog</code>，初始化：</p>
<pre><code>$ hexo init
</code></pre></li>
</ol>
<p>这里可能出现初始化错误，原因就是默认的npm出现连接错误，你需要手动执行<code>$ cnpm install</code>。<br>cnpm就是淘宝镜像的命令。</p>
<ol>
<li><p>安装server，用于本地调试：</p>
<pre><code>$ cnpm install hexo-server --save
</code></pre></li>
</ol>
<p>如果不安装，现在的版本是不在带服务器的，导致后面执行<code>hexo server</code>报没有命令的错误。</p>
<ol>
<li><p>生成静态页面：</p>
<pre><code>$ hexo generate 或 $ hexo g
</code></pre></li>
<li><p>启动本地服务，进行文章预览调试：</p>
<pre><code>$ $hexo server或 $ hexo s。
</code></pre></li>
</ol>
<p>启动成功，根据提示在浏览器浏览器输入 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 即可查看。</p>
<h4 id="hexo一些常用命令-可以通过hexo-help查看-："><a href="#hexo一些常用命令-可以通过hexo-help查看-：" class="headerlink" title="hexo一些常用命令(可以通过hexo help查看)："></a>hexo一些常用命令(可以通过<code>hexo help</code>查看)：</h4><ul>
<li><p><code>hexo new &quot;postName&quot;</code> #新建文章</p>
</li>
<li><p><code>hexo new page &quot;pageName&quot;</code> #新建页面</p>
</li>
<li><p><code>hexo generate</code> #生成静态页面至public目录</p>
</li>
<li><p><code>hexo server</code> #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</p>
</li>
<li><p><code>hexo deploy</code> #将.deploy目录部署到GitHub</p>
</li>
<li><p><code>hexo help</code> # 查看帮助</p>
</li>
<li><p><code>hexo version</code> #查看Hexo的版本</p>
</li>
</ul>
<h4 id="hexo关联配置Github"><a href="#hexo关联配置Github" class="headerlink" title="hexo关联配置Github"></a>hexo关联配置Github</h4><ul>
<li><p>关联之前，你得先创建好自己的<a href="https://pages.github.com/" target="_blank" rel="external">GitHub Pages</a>，按着官方教程一步步来，或者自己google。</p>
</li>
<li><p>修改<code>blog</code>下的配置文件<code>_config.xml</code>:（repo的地址写你自己的GitHub Pages项目地址啊）</p>
<pre><code>deploy:

     type: git

     repo: https://github.com/fenglai0802/fenglai0802.github.io.git

    branch: master
</code></pre></li>
<li><p>安装发布命令：</p>
<pre><code>$ cnpm install hexo-deployer-git --save
</code></pre></li>
<li><p>执行命名：</p>
<pre><code>$ hexo deploy
</code></pre></li>
</ul>
<p>此时public文件夹下的内容就会被上传到你的github中fenglai0802.github.io的这个项目下。</p>
<ul>
<li><p>然后再浏览器中输入 <a href="https://fenglai0802.github.io/" target="_blank" rel="external">https://fenglai0802.github.io/</a> 就可以查看了。</p>
</li>
<li><p>每次部署的步骤，可按以下三步来进行。(建议自己写一个shell方便发布)</p>
<pre><code>$ hexo clean

$ hexo generate

$ hexo deploy
</code></pre></li>
</ul>
<h2 id="3-hexo主题篇"><a href="#3-hexo主题篇" class="headerlink" title="3. hexo主题篇"></a>3. hexo主题篇</h2><ul>
<li><a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">主题汇总</a>。使用方法里面也有介绍，简单讲就是把主题克隆到theme文件夹，然后修改_config.yml配置文件中的theme选项就行。</li>
<li>这里比较推荐主题<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">NexT</a>。自用就是这个，哈哈~</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/03/利用模块n管理node版本/" itemprop="url">
                  利用模块n管理node版本
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-03T10:44:47+08:00" content="2016-08-03">
              2016-08-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/常规/" itemprop="url" rel="index">
                    <span itemprop="name">常规</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="利用模块n管理node版本"><a href="#利用模块n管理node版本" class="headerlink" title="利用模块n管理node版本"></a>利用模块n管理node版本</h3><ul>
<li>由于node的版本迭代速度非常快，所以版本多样，所以升级版本或者切换版本都比较麻烦。本文介绍一下模块n的好处。</li>
</ul>
<h5 id="n"><a href="#n" class="headerlink" title="n"></a>n</h5><ul>
<li><p>n是node的一个模块，作者是TJ Holowaychuk（鼎鼎大名的Express框架作者），就像它的名字一样，它的理念就是简单：</p>
<blockquote>
<p>no subshells, no profile setup, no convoluted api, just simple</p>
</blockquote>
</li>
<li><p>安装n</p>
<pre><code>$ sudo npm install -g n
</code></pre></li>
<li><p>安装完成之后，直接输入n后控制台就会输出当前已安装的node版本以及正在使用的版本（前面有个o的），通过上下方向键来选择想要使用的版本，回车生效。</p>
<pre><code>$ n
    0.10.1
o   6.0.0
</code></pre></li>
<li><p>安装指定版本node</p>
<pre><code>$ n 6.0.0
</code></pre></li>
<li><p>安装最新版本node</p>
<pre><code>$ n latest
</code></pre></li>
<li><p>安装稳定版本node</p>
<pre><code>$ n stable
</code></pre></li>
<li><p>删除某个版本</p>
<pre><code>$ n rm 0.10.1
</code></pre></li>
<li><p>以指定的版本来执行脚本</p>
<pre><code>$ n use 0.10.21 some.js
</code></pre></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/heiyue.jpeg"
               alt="黑月" />
          <p class="site-author-name" itemprop="name">黑月</p>
          <p class="site-description motion-element" itemprop="description">弱小和无知不是生存的障碍，傲慢才是。</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fenglai0802" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黑月</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
